GetCurrentQuotesFromWeb = function() {
address <- .self$web_api_address
if(!grepl("^https://", address))
address <- paste0("https://", address)
portPattern <- paste0(":", .self$web_api_port, "$")
if(!grepl(portPattern, address))
address <- paste0(address, ":", .self$web_api_port)
if(length(.self$web_api_id) != 0 && length(.self$web_api_key) != 0 && length(.self$web_api_secret) != 0){
url_rel <- paste("/api/v2/tick")
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE),
httr::add_headers(Authorization = getHMACHeaders(url_abs, .self$web_api_id, .self$web_api_key, .self$web_api_secret)))
}else{
url_rel <- paste("/api/v2/public/tick")
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE))
}
data <- httr::content(connect, "text", encoding = "UTF-8")
if(connect$status_code != 200) {
stop(paste("status_code is not OK", connect$status_code, as.character(data)))
}
# data <- content(connect, "text", encoding = "UTF-8")
ticks <- fromJSON(data)
ticks <- data.table("TimeStamp" = ticks$Timestamp, "Symbol" = ticks$Symbol, "BidPrice" = ticks$BestBid$Price,
"BidVolume" = ticks$BestBid$Volume, "BidType" = ticks$BestBid$Type,  "AskPrice" = ticks$BestAsk$Price,
"AskVolume" = ticks$BestAsk$Volume, "AskType" = ticks$BestAsk$Type)
return(ticks)
}
)
#' Get All Symbols
#' @name GetSymbolsInfoFromWeb
#' @return data.table with symbol info
RTTWebClient$methods(
GetSymbolsInfoFromWeb = function(){
address <- .self$web_api_address
if(!grepl("^https://", address))
address <- paste0("https://", address)
portPattern <- paste0(":", .self$web_api_port, "$")
if(!grepl(portPattern, address))
address <- paste0(address, ":", .self$web_api_port)
if(length(.self$web_api_id) != 0 && length(.self$web_api_key) != 0 && length(.self$web_api_secret) != 0){
url_rel <- paste("/api/v2/symbol")
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE),
httr::add_headers(Authorization = getHMACHeaders(url_abs, .self$web_api_id, .self$web_api_key, .self$web_api_secret)))
}else{
url_rel <- paste("/api/v2/public/symbol")
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE))
}
data <- httr::content(connect, "text", encoding = "UTF-8")
if(connect$status_code != 200) {
stop(paste("status_code is not OK", connect$status_code, as.character(data)))
}
data = fromJSON(data)
symbols <- as.data.table(data)
setkey(symbols, "Symbol")
return(symbols)
}
)
#' Get Bar History
#' @name GetBarFromWeb
#' @param symbol a character. Symbol Name.
#' @param barsType. a character. Bars Type. One from c("Ask", "Bid").
#' @param periodicity. a character. Periodicity. From c("S1", "S10", "M1", "M5", "M15", "M30", "H1", "H4", "D1", "W1","MN1")
#' @param startTimeMs. Long numeric. Timestamp from 1970-01-01 in ms.
#' @param count. Integer. Count of returned Bars from startTimeMs. Max is 1000. Can be negative.
#' @return data.table with Bar Info
RTTWebClient$methods(
GetBarFromWeb = function(symbol, barsType, periodicity, startTimeMs, count){
address <- .self$web_api_address
if(!grepl("^https://", address))
address <- paste0("https://", address)
portPattern <- paste0(":", .self$web_api_port, "$")
if(!grepl(portPattern, address))
address <- paste0(address, ":", .self$web_api_port)
if(length(.self$web_api_id) != 0 && length(.self$web_api_key) != 0 && length(.self$web_api_secret) != 0){
url_rel <- paste("/api/v2/quotehistory",symbol, periodicity, "bars", barsType, sep= "/")
url_rel <- paste0(url_rel,"?","timestamp=",round(startTimeMs, 0),"&count=", count)
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE),
add_headers(Authorization = getHMACHeaders(url_abs, .self$web_api_id, .self$web_api_key, .self$web_api_secret)))
}else{
url_rel <- paste("/api/v2/public/quotehistory",symbol, periodicity, "bars", barsType, sep= "/")
url_rel <- paste0(url_rel,"?","timestamp=",round(startTimeMs, 0),"&count=", count)
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE))
}
data <- httr::content(connect, "text", encoding = "UTF-8")
if(connect$status_code != 200) {
stop(paste("status_code is not OK", connect$status_code, as.character(data)))
}
bars <- fromJSON(data)
bars <- as.data.table(bars$Bars)
return(bars)
}
)
#'Get Ticks History
#' @name GetTicksFromWeb
#' @param symbol. A character. Symbol Name.
#' @param startTimeMs. Long numeric. Timestamp from 1970-01-01 in ms.
#' @param count. Integer. Count of returned Bars from startTimeMs. Max is 1000. Can be negative.
#' @return data.table with Ticks Info.
RTTWebClient$methods(
GetTicksFromWeb = function(symbol, startTimeMs, count){
address <- .self$web_api_address
if(!grepl("^https://", address))
address <- paste0("https://", address)
portPattern <- paste0(":", .self$web_api_port, "$")
if(!grepl(portPattern, address))
address <- paste0(address, ":", .self$.self$web_api_port)
if(length(.self$web_api_id) != 0 && length(.self$web_api_key) != 0 && length(.self$web_api_secret) != 0){
url_rel <- paste("/api/v2/quotehistory",symbol, "ticks", sep= "/")
url_rel <- paste0(url_rel,"?","timestamp=",round(startTimeMs, 0),"&count=", count)
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE),
add_headers(Authorization = getHMACHeaders(url_abs, .self$web_api_id, .self$web_api_key, .self$web_api_secret)))
}else{
url_rel <- paste("/api/v2/public/quotehistory",symbol, "ticks", sep= "/")
url_rel <- paste0(url_rel,"?","timestamp=",round(startTimeMs, 0),"&count=", count)
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE))
}
data <- httr::content(connect, "text", encoding = "UTF-8")
if(connect$status_code != 200) {
stop(paste("status_code is not OK", connect$status_code, as.character(data)))
}
ticks <- fromJSON(data)
ticks <- ticks$Ticks
ticks <- data.table("Timestamp" = ticks$Timestamp, "BidPrice" = ticks$BestBid$Price,
"BidVolume" = ticks$BestBid$Volume, "BidType" = ticks$BestBid$Type,  "AskPrice" = ticks$BestAsk$Price,
"AskVolume" = ticks$BestAsk$Volume, "AskType" = ticks$BestAsk$Type)
return(ticks)
}
)
#' Init Public Web Client Obj
#'@name InitPublicWebClient
#'@param server a character. Web Address.
#'@param port an integer. Port Number. Default is 8443
InitPublicWebClient <- function(server = "ttlivewebapi.fxopen.com", port=8443L) {
options(scipen = 999)
return(RTTWebClient(web_api_address=server,
web_api_port = port))
}
#' Init Private Web Client Obj
#'@name InitPrivateWebClient
#'@param server a character. Web Address.
#'@param port an integer. Port Number. Default is 8443
#'@param we
InitPrivateWebClient <- function(server = "ttlivewebapi.fxopen.com", port=8443L, id = "", key = "", secret = "") {
options(scipen = 999)
return(RTTWebClient(web_api_address=server,
web_api_port = port,
web_api_id = id,
web_api_key=key,
web_api_secret=secret))
}
#' Init Web connect to TT
#' @name ttInitialize
#' @param
# ttInitialize <- setRefClass("ttInitialize",
#                             fields = list(server = "character", port = "numeric", id = "character", key = "character", secret = "character"),
#                             methods = list(
#                               initialize = function(webClient) {
#                                 if(isPublic)
#                                 .self$webClient = InitPublicWebClient()
#                               }
#                             )
#                             )
WebClient <- setRefClass("WebClient",
fields = list(client = "RTTWebClient"),
methods = list(
initialize = function(newWebClient){
.self$client <- newWebClient
}
))
WebClient$methods(
GetDividends = function() {
return(.self$client$GetDividendsFromWeb())
}
)
WebClient$methods(
GetSymbolsInfo = function() {
return(.self$client$GetSymbolsInfoFromWeb())
}
)
WebClient$methods(
GetCurrentQuotes = function() {
return(.self$client$GetCurrentQuotesFromWeb())
}
)
WebClient$methods(
GetBarsHistory = function(symbol, barsType = "Bid", periodicity = "M1", startTime, endTime = as.POSIXct(Sys.Date(), tz = "GMT"), count = 0) {
if(barsType == "Bid" || barasType == "Ask"){
return(GetBars(.self$client$GetBarFromWeb, symbol, barsType, periodicity, startTime, endTime, count))
}
stop("Wrong Bar Type")
}
)
WebClient$methods(
GetTickHistory = function(symbol, startTime, endTime = as.POSIXct(Sys.Date(), tz = "GMT"), count = 0) {
return(GetTicks(.self$client$GetTicksFromWeb, symbol, startTime, endTime, count))
}
)
# WebClient <- function(server = "ttlivewebapi.fxopen.com", port=8443L, id = NULL, key = NULL, secret = NULL){
#   if(length(id) != 0 && length(key) != 0 && length(secret) != 0)
#     return(ttInitialize$new(InitPrivateWebClient(server, port, id, key, secret)))
#   return(ttInitialize$new(InitPublicWebClient(server, port)))
# }
#' Init WebClient
#'@param server a character. Web Address.
#'@param port an integer. Port Number. Default is 8443
#'@param id a character. HMAC client id.
#'@param key a character. HMAC client key.
#'@param secret a character. HMAC secret key.
#'@return WebClient ref class.
#'@export
InitWebClient <- function(server = "ttlivewebapi.fxopen.com", port=8443L, id = NULL, key = NULL, secret = NULL){
if(length(id) != 0 && length(key) != 0 && length(secret) != 0)
return(ttInitialize$new(InitPrivateWebClient(server, port, id, key, secret)))
return(ttInitialize$new(InitPublicWebClient(server, port)))
}
r <- InitWebClient()
#' Init WebClient
#'@param server a character. Web Address.
#'@param port an integer. Port Number. Default is 8443
#'@param id a character. HMAC client id.
#'@param key a character. HMAC client key.
#'@param secret a character. HMAC secret key.
#'@return WebClient ref class.
#'@export
InitWebClient <- function(server = "ttlivewebapi.fxopen.com", port=8443L, id = NULL, key = NULL, secret = NULL){
if(length(id) != 0 && length(key) != 0 && length(secret) != 0)
return(WebClient$new(InitPrivateWebClient(server, port, id, key, secret)))
return(WebClient$new(InitPublicWebClient(server, port)))
}
r <- InitWebClient()
r$GetDividends()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
install.packages("C:/Users/yury.maisiayonak/Desktop/RTTWebClient_0.1.0.tar.gz", repos = NULL, type = "source")
library(RTTWebClient)
help(package = "RTTWebClient")
help(package = "RTTWebClient")
library(RTTWebClient)
t1 <- InitWebClient()
t1$GetSymbolsInfo()
r <- t1$GetSymbolsInfo()
library(lubridate)
t1$GetTickHistory("EURUSD", now("UTC") - hours(1), now("UTC"))
library(rhub)
rhub::check_for_cran()
help("Documentation", package = "methods")
methods ? GetDividendsFromWeb
promptMethods ("GetDividendsFromWeb")
promptMethods ("GetBars")
rhub::check_for_cran()
rhub::check_for_cran()
detach("package:RTTWebClient", unload = TRUE)
install.packages("C:/Users/yury.maisiayonak/Desktop/RTTWebClient_0.1.0.tar.gz", repos = NULL, type = "source")
install.packages("C:/Users/yury.maisiayonak/Desktop/RTTWebClient_0.1.0.tar.gz", repos = NULL, type = "source")
library(RTTWebClient)
t1 <- InitPrivateWebClient()
t1$GetCurrentQuotesFromWeb()
t1 <- InitPublicWebClient()
t1$GetCurrentQuotesFromWeb()
library(RTTWebClient)
ttWebClient <- InitPublicWebClient(server = "tt.tt-ag.st.soft-fx.eu")
help(package = "RTTWebClient")
ttWebClient$GetTickHistory("EURUSD",  round(as.double(Sys.time()) * 1000), count = -10)
ttWebClient <- InitPublicWebClient(server = "tt.tt-ag.st.soft-fx.eu")
print(ttWebClient$GetTicksFromWeb("EURUSD",  round(as.double(Sys.time()) * 1000), count = -10))
t1 <- Sys.time()
t1
t1 - 10
library(RTTWebClient)
library(lubridate)
ttWebApiHost <- InitRTTWebApiHost(server = "tt.tt-ag.st.soft-fx.eu")
tt1 <- InitWebClient()
devtools::release()
devtools::spell_check()
devtools::release()
install.packages("xfun")
install.packages(c('data.table','jsonlite','httr','foreach','base64enc'))
install.packages("lubridate")
install.packages("rmarkdown")
install.packages("pdflatex")
Sys.setenv(PATH = paste(Sys.getenv("PATH")
)
_
library(knitr)
install.packages("tidyLPA")
tools::texi2pdf()
search()
TinyTeX
install.packages("tinytex")
install.packages("tinytex")
Sys.getenv("PATH")
Sys.getenv("PATH")
install.packages("devtools")
devtools::release()
devtools::spell_check()
devtools::release()
devtools::release()
devtools::check_rhub()
help(package = "data.table")
install.packages("C:/Users/Yury/Desktop/RTTWebClient_0.1.0.tar.gz", repos = NULL, type = "source")
library(RTTWebClient)
client <- InitPublicWebClient()
client$GetCurrentQuotesFromWeb()
client2 <- InitRTTWebApiHost()
library(lubridate)
client2$GetTickHistory("EURUSD", now("UTC") - minutes(10), now("UTC"))
GetTicks <- function(GetTickMethod, symbol, startTime, endTime, count) {
tempStartTime <- as.double(startTime)*1000
history <- data.table()
maxCount <- 1000
if(count == 0) {
repeat{
ticks <- GetTickMethod(symbol, tempStartTime, maxCount)
excludeIndex <-ifelse(is.null(history[.N, Timestamp]), numeric(0), ticks[Timestamp==history[.N, Timestamp],which=T])
if(!is.na(excludeIndex))
ticks <-ticks[-excludeIndex]
if(nrow(ticks) == 0) {
break;
}else{
endTimeInMs <- as.double(endTime) * 1000
if(ticks[.N, Timestamp] >= endTimeInMs){
history = rbind(history, ticks[Timestamp <= endTimeInMs])
break;
}
}
history <- rbind(history, ticks)
tempStartTime <- history[.N, Timestamp]
}
}else{
if(abs(count) < maxCount){
history <- GetTickMethod(symbol, tempStartTime, count)
}else{
history <- GetTickMethod(symbol, tempStartTime, maxCount * sign(count))
}
}
history[, Timestamp := as.POSIXct(Timestamp / 1000, origin = "1970-01-01", tz = "GMT")]
setkey(history, Timestamp)
return(history)
}
GetTicks(client$GetCurrentQuotesFromWeb, "EURUSD",  now("UTC") - minutes(10), now("UTC"), 0)
library(data.table)
GetTicks(client$GetCurrentQuotesFromWeb, "EURUSD",  now("UTC") - minutes(10), now("UTC"), 0)
client$GetCurrentQuotesFromWeb()
client$GetCurrentQuotesFromWeb
t1 <- client$GetCurrentQuotesFromWeb
t1
GetTicks(t1, "EURUSD",  now("UTC") - minutes(10), now("UTC"), 0)
GetTicks(client$GetTicksFromWeb, "EURUSD",  now("UTC") - minutes(10), now("UTC"), 0)
GetTicks(client$GetTicksFromWeb, "EURUSD",  now("UTC") - minutes(10), now("UTC"), 0)
debug(GetTicks(client$GetTicksFromWeb, "EURUSD",  now("UTC") - minutes(10), now("UTC"), 0))
GetTickMethod <- client$GetTicksFromWeb
symbol <- "EURUSD"
startTime = now("UTC") - minutes(10); endTime = now("UTC"); count = 0
tempStartTime <- as.double(startTime)*1000
history <- data.table()
maxCount <- 1000
ticks <- GetTickMethod(symbol, tempStartTime, maxCount)
excludeIndex <-ifelse(is.null(history[.N, Timestamp]), numeric(0), ticks[Timestamp==history[.N, Timestamp],which=T])
lastHistoryNoteTimestamp <- history[.N, Timestamp]
history
history[.N]$Timestamp
ticks
history
colnames(ticks)
Timestamp
data.table::`.__T__[<-:base`
history
history[.N]
history[.N]$Timestamp
history[.N, Timestamp]
history[.N, Timestamp, warning = FALSe]
history[.N, Timestamp,]
history[.N,c("Timestamp")]
GetTickMethod
tempStartTime <- as.double(startTime)*1000
history <- data.table("Timestamp" = as.POSIXct(character(), tz = "GMT"),
"BidPrice" = numeric() , "BidVolume" = numeric(),
"BidType" = chraacter(), "AskPrice" = numeric(),
"AskVolume" = numeric(),  "AskType" = character() )
history <- data.table("Timestamp" = as.POSIXct(character(), tz = "GMT"),
"BidPrice" = numeric() , "BidVolume" = numeric(),
"BidType" = character(), "AskPrice" = numeric(),
"AskVolume" = numeric(),  "AskType" = character() )
history
ticks <- GetTickMethod(symbol, tempStartTime, maxCount)
lastHistoryNoteTimestamp <- history[.N, Timestamp]
lastHistoryNoteTimestamp
is.null(lastHistoryNoteTimestamp)
is.null(lastHistoryNoteTimestamp)
ticks <- GetTickMethod(symbol, tempStartTime, maxCount)
lastHistoryNoteTimestamp <- history[.N, Timestamp]
excludeIndex <-ifelse(length(lastHistoryNoteTimestamp) <= 0, numeric(0), ticks[Timestamp==lastHistoryNoteTimestamp, which=TRUE])
excludeIndex
maxCount <- 1000
if(count == 0) {
repeat{
ticks <- GetTickMethod(symbol, tempStartTime, maxCount)
lastHistoryNoteTimestamp <- history[.N, Timestamp]
excludeIndex <-ifelse(length(lastHistoryNoteTimestamp) <= 0, numeric(0), ticks[Timestamp==lastHistoryNoteTimestamp, which=TRUE])
if(!is.na(excludeIndex))
ticks <-ticks[-excludeIndex]
if(nrow(ticks) == 0) {
break;
}else{
endTimeInMs <- as.double(endTime) * 1000
if(ticks[.N, Timestamp] >= endTimeInMs){
history = rbind(history, ticks[Timestamp <= endTimeInMs])
break;
}
}
history <- rbind(history, ticks)
tempStartTime <- history[.N, Timestamp]
}
}else{
if(abs(count) < maxCount){
history <- GetTickMethod(symbol, tempStartTime, count)
}else{
history <- GetTickMethod(symbol, tempStartTime, maxCount * sign(count))
}
}
ticks <- GetTickMethod(symbol, tempStartTime, maxCount)
lastHistoryNoteTimestamp <- history[.N, Timestamp]
excludeIndex <-ifelse(length(lastHistoryNoteTimestamp) <= 0, numeric(0), ticks[Timestamp==lastHistoryNoteTimestamp, which=TRUE])
if(!is.na(excludeIndex))
ticks <-ticks[-excludeIndex]
if(nrow(ticks) == 0) {
break;
}else{
endTimeInMs <- as.double(endTime) * 1000
if(ticks[.N, Timestamp] >= endTimeInMs){
history = rbind(history, ticks[Timestamp <= endTimeInMs])
break;
}
}
history <- rbind(history, ticks)
history
icks[Timestamp <= endTimeInMs]
ticks[Timestamp <= endTimeInMs]
history = rbind(history, ticks[Timestamp <= endTimeInMs])
history
history <- data.table("Timestamp" = numeric(),
"BidPrice" = numeric() , "BidVolume" = numeric(),
"BidType" = character(), "AskPrice" = numeric(),
"AskVolume" = numeric(),  "AskType" = character() )
ticks <- GetTickMethod(symbol, tempStartTime, maxCount)
lastHistoryNoteTimestamp <- history[.N, Timestamp]
excludeIndex <-ifelse(length(lastHistoryNoteTimestamp) <= 0, numeric(0), ticks[Timestamp==lastHistoryNoteTimestamp, which=TRUE])
if(!is.na(excludeIndex))
ticks <-ticks[-excludeIndex]
if(nrow(ticks) == 0) {
break;
}else{
endTimeInMs <- as.double(endTime) * 1000
if(ticks[.N, Timestamp] >= endTimeInMs){
history = rbind(history, ticks[Timestamp <= endTimeInMs])
break;
}
}
history
GetBarMethod <- client$GetBarFromWeb
startTime = now("UTC") - minutes(10); endTime = now("UTC"); count = 0
barsType = "Bid", periodicity = "M1"
barsType = "Bid"; periodicity = "M1"
symbol
bars <- GetBarMethod(symbol, barsType, periodicity, tempStartTime, maxCount)
bars
colnames(bars)
bars <- GetBarMethod(symbol, barsType, periodicity, tempStartTime, maxCount)
lastHistoryNoteTimestamp <- history[.N, Timestamp]
excludeIndex <-ifelse(length(lastHistoryNoteTimestamp) <= 0, numeric(0), bars[Timestamp==lastHistoryNoteTimestamp,which=T])
if(!is.na(excludeIndex))
bars <-bars[-excludeIndex]
if(nrow(bars) == 0) {
break;
}else{
endTimeInMs <- as.double(endTime) * 1000
if(bars[.N, Timestamp] >= endTimeInMs){
history = rbind(history, bars[Timestamp <= endTimeInMs])
break;
}
}
history
history <- data.table("Volume"= numeric(),
"Close" = numeric(), "Low"= numeric(),"High"= numeric(), "Open"= numeric(),
"Timestamp"= numeric())
bars <- GetBarMethod(symbol, barsType, periodicity, tempStartTime, maxCount)
lastHistoryNoteTimestamp <- history[.N, Timestamp]
excludeIndex <-ifelse(length(lastHistoryNoteTimestamp) <= 0, numeric(0), bars[Timestamp==lastHistoryNoteTimestamp,which=T])
if(!is.na(excludeIndex))
bars <-bars[-excludeIndex]
if(nrow(bars) == 0) {
break;
}else{
endTimeInMs <- as.double(endTime) * 1000
if(bars[.N, Timestamp] >= endTimeInMs){
history = rbind(history, bars[Timestamp <= endTimeInMs])
break;
}
}
history <- rbind(history, bars)
history
isntall.packages("qpdf")
install.packages("qpdf")
