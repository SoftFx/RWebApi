address <- paste0(address, ":", .self$.self$web_api_port)
if(length(.self$web_api_id) != 0 && length(.self$web_api_key) != 0 && length(.self$web_api_secret) != 0){
url_rel <- paste("/api/v2/quotehistory",symbol, "ticks", sep= "/")
url_rel <- paste0(url_rel,"?","timestamp=",round(startTimeMs, 0),"&count=", count)
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE),
add_headers(Authorization = getHMACHeaders(url_abs, .self$web_api_id, .self$web_api_key, .self$web_api_secret)))
}else{
url_rel <- paste("/api/v2/public/quotehistory",symbol, "ticks", sep= "/")
url_rel <- paste0(url_rel,"?","timestamp=",round(startTimeMs, 0),"&count=", count)
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE))
}
data <- httr::content(connect, "text", encoding = "UTF-8")
if(connect$status_code != 200) {
stop(paste("status_code is not OK", connect$status_code, as.character(data)))
}
ticks <- fromJSON(data)
ticks <- ticks$Ticks
ticks <- data.table("Timestamp" = ticks$Timestamp, "BidPrice" = ticks$BestBid$Price,
"BidVolume" = ticks$BestBid$Volume, "BidType" = ticks$BestBid$Type,  "AskPrice" = ticks$BestAsk$Price,
"AskVolume" = ticks$BestAsk$Volume, "AskType" = ticks$BestAsk$Type)
return(ticks)
}
)
#' Create WebClient Obj
#'
PublicClient <- function(server = "ttlivewebapi.fxopen.com", port=8443L, id, key, secret) {
options(scipen = 999)
return(RTTWebClient(web_api_address=server,
web_api_port = port))
}
PrivateClient <- function(server = "ttlivewebapi.fxopen.com", port=8443L, id = "", key = "", secret = "") {
options(scipen = 999)
return(RTTWebClient(web_api_address=server,
web_api_port = port,
web_api_id = id,
web_api_key=key,
web_api_secret=secret))
}
t1 <- PublicClient()
t1$GetCurrentQuotesFromWeb()
ttInitialize <- setRefClass("ttInitialize",
fields = "RTTWebClient")
r <- ttInitialize()
r1 <- r$RTTWebClient
r1$
f
r1 <- r$RTTWebClient()
r1 <- r$RTTWebClient(web_api_address="",
web_api_port = port,
web_api_id = id,
web_api_key=key,
web_api_secret=secret)
server = "ttlivewebapi.fxopen.com", port=8443L, id = "", key = "", secret = ""
server = "ttlivewebapi.fxopen.com"; port=8443L;id = ""; key = ""; secret = "";
r1 <- r$RTTWebClient(web_api_address="",
web_api_port = port,
web_api_id = id,
web_api_key=key,
web_api_secret=secret)
r1 <- r$RTTWebClient(web_api_address=server,
web_api_port = port,
web_api_id = id,
web_api_key=key,
web_api_secret=secret)
server
port
id
key
secret
ttInitialize <- setRefClass("ttInitialize",
fields = list(webClient = "RTTWebClient"),
)
r <- ttInitialize()
r
r$webClient$GetBarFromWeb
r$webClient$GetBarFromWeb()
r$webClient$GetDividendsFromWeb()
WebClient <- setRefClass("WebClient",
fields = list(client = "RTTWebClient"),
methods = list(
initialize = function(newWebClient){
.self$client <- newWebClient
}
))
library(data.table)
library(digest)
library(jsonlite)
library(base64enc)
GetBars <- function(GetBarMethod, symbol, barsType = "Bid", periodicity = "M1", startTime, endTime, count) {
tempStartTime <- as.double(startTime)*1000
history <- data.table()
maxCount <- 1000
if(count == 0) {
repeat{
bars <- GetBarMethod(symbol, barsType, periodicity, tempStartTime, maxCount)
excludeIndex <-ifelse(is.null(history[.N]$Timestamp), numeric(0), bars[Timestamp==history[.N]$Timestamp,which=T])
if(!is.na(excludeIndex))
bars <-bars[-excludeIndex]
if(nrow(bars) == 0) {
break;
}else{
endTimeInMs <- as.double(endTime) * 1000
if(bars[.N]$Timestamp >= endTimeInMs){
history = rbind(history, bars[Timestamp <= endTimeInMs])
break;
}
}
history <- rbind(history, bars)
tempStartTime <- history[.N]$Timestamp
}
}else{
if(abs(count) < maxCount){
history <- GetBarMethod(symbol, barsType, periodicity, tempStartTime, count)
}else{
history <- GetBarMethod(symbol, barsType, periodicity, tempStartTime, maxCount * sign(count))
}
}
history$Timestamp <- as.POSIXct(history$Timestamp/1000, origin = "1970-01-01", tz = "GMT")
setkey(history, Timestamp)
return(history)
}
GetTicks <- function(GetTickMethod, symbol, startTime, endTime, count) {
tempStartTime <- as.double(startTime)*1000
history <- data.table()
maxCount <- 1000
if(count == 0) {
repeat{
ticks <- GetTickMethod(symbol, tempStartTime, maxCount)
excludeIndex <-ifelse(is.null(history[.N]$Timestamp), numeric(0), ticks[Timestamp==history[.N]$Timestamp,which=T])
if(!is.na(excludeIndex))
ticks <-ticks[-excludeIndex]
if(nrow(ticks) == 0) {
break;
}else{
endTimeInMs <- as.double(endTime) * 1000
if(ticks[.N]$Timestamp >= endTimeInMs){
history = rbind(history, ticks[Timestamp <= endTimeInMs])
break;
}
}
history <- rbind(history, ticks)
tempStartTime <- history[.N]$Timestamp
}
}else{
if(abs(count) < maxCount){
history <- GetTickMethod(symbol, tempStartTime, count)
}else{
history <- GetTickMethod(symbol, tempStartTime, maxCount * sign(count))
}
}
history$Timestamp <- as.POSIXct(history$Timestamp/1000, origin = "1970-01-01", tz = "GMT")
setkey(history, Timestamp)
return(history)
}
GetBidAskBar <- function(GetBarMethod, symbol, periodicity = "M1", startTime, endTime, count) {
bidBars <- GetBars(GetBarMethod, symbol, barsType = "Bid", periodicity, startTime, endTime, count)
askBars <- GetBars(GetBarMethod, symbol, barsType = "Ask", periodicity, startTime, endTime, count)
bidAskBars <- merge(bidBars, askBars)
colnames(bidAskBars) <- c("Timestamp", "BidVolume", "BidClose", "BidLow", "BidHigh", "BidOpen",
"AskVolume", "AskClose", "AskLow", "AskHigh", "AskOpen")
return(bidAskBars)
}
# Get current time in ms
getTimestamp = function() {
return(round(as.double(Sys.time()) * 1000))
}
# Generate HMAC Headers from
getHMACHeaders = function(url, id, key, secret, method = "GET", body = "") {
timestamp1 <- getTimestamp()
signature <- paste0(timestamp1, id, key, method, url, body)
hash_value <- base64enc::base64encode(hmac(secret, signature, algo = "sha256", raw = TRUE))
auth_value <- paste("HMAC",paste(id, key, timestamp1, hash_value, sep = ":"))
return(auth_value)
}
#' RTTWebClient Class
#' @name RTTWebClient
#' @field web_api_address. Server address. Character
#' @field web_api_port. Port. Integer
#' @field web_api_id. Web Api Id. Character
#' @field web_api_key. Web Api Key. Character
#' @field web_api_secrer. Web Api Secret. Character
#' @import data.table
#' @import jsonlite
#' @export RTTWebClient
#' @exportClass RTTWebClient
RTTWebClient <- setRefClass("RTTWebClient",
fields = list(web_api_address = "character",
web_api_port = "integer",
web_api_id = "character",
web_api_key = "character",
web_api_secret= "character")
)
#' Get All Dividend
#' @name GetDividendsFromWeb
#' @return a data.table with dividends.
RTTWebClient$methods(
GetDividendsFromWeb = function() {
address <- .self$web_api_address
if(!grepl("^https://", address))
address <- paste0("https://", address)
portPattern <- paste0(":", .self$web_api_port, "$")
if(!grepl(portPattern, address))
address <- paste0(address, ":", .self$web_api_port)
if(length(.self$web_api_id) != 0 && length(.self$web_api_key) != 0 && length(.self$web_api_secret) != 0){
url_rel <- paste("/api/v2/dividend")
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE),
httr::add_headers(Authorization = getHMACHeaders(url_abs, .self$web_api_id, .self$web_api_key, .self$web_api_secret)))
}else{
url_rel <- paste("/api/v2/public/dividend")
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE))
}
data <- httr::content(connect, "text", encoding = "UTF-8")
if(connect$status_code != 200) {
stop(paste("status_code is not OK", connect$status_code, as.character(data)))
}
dividends <- fromJSON(data)
dividends <- as.data.table(dividends)
return(dividends)
}
)
#' Get All Current Quotes
#' @name GetCurrentQuotesFromWeb
#' @return a data.table with current quotes
RTTWebClient$methods(
GetCurrentQuotesFromWeb = function() {
address <- .self$web_api_address
if(!grepl("^https://", address))
address <- paste0("https://", address)
portPattern <- paste0(":", .self$web_api_port, "$")
if(!grepl(portPattern, address))
address <- paste0(address, ":", .self$web_api_port)
if(length(.self$web_api_id) != 0 && length(.self$web_api_key) != 0 && length(.self$web_api_secret) != 0){
url_rel <- paste("/api/v2/tick")
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE),
httr::add_headers(Authorization = getHMACHeaders(url_abs, .self$web_api_id, .self$web_api_key, .self$web_api_secret)))
}else{
url_rel <- paste("/api/v2/public/tick")
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE))
}
data <- httr::content(connect, "text", encoding = "UTF-8")
if(connect$status_code != 200) {
stop(paste("status_code is not OK", connect$status_code, as.character(data)))
}
# data <- content(connect, "text", encoding = "UTF-8")
ticks <- fromJSON(data)
ticks <- data.table("TimeStamp" = ticks$Timestamp, "Symbol" = ticks$Symbol, "BidPrice" = ticks$BestBid$Price,
"BidVolume" = ticks$BestBid$Volume, "BidType" = ticks$BestBid$Type,  "AskPrice" = ticks$BestAsk$Price,
"AskVolume" = ticks$BestAsk$Volume, "AskType" = ticks$BestAsk$Type)
return(ticks)
}
)
#' Get All Symbols
#' @name GetSymbolsInfoFromWeb
#' @return data.table with symbol info
RTTWebClient$methods(
GetSymbolsInfoFromWeb = function(){
address <- .self$web_api_address
if(!grepl("^https://", address))
address <- paste0("https://", address)
portPattern <- paste0(":", .self$web_api_port, "$")
if(!grepl(portPattern, address))
address <- paste0(address, ":", .self$web_api_port)
if(length(.self$web_api_id) != 0 && length(.self$web_api_key) != 0 && length(.self$web_api_secret) != 0){
url_rel <- paste("/api/v2/symbol")
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE),
httr::add_headers(Authorization = getHMACHeaders(url_abs, .self$web_api_id, .self$web_api_key, .self$web_api_secret)))
}else{
url_rel <- paste("/api/v2/public/symbol")
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE))
}
data <- httr::content(connect, "text", encoding = "UTF-8")
if(connect$status_code != 200) {
stop(paste("status_code is not OK", connect$status_code, as.character(data)))
}
data = fromJSON(data)
symbols <- as.data.table(data)
setkey(symbols, "Symbol")
return(symbols)
}
)
#' Get Bar History
#' @name GetBarFromWeb
#' @param symbol a character. Symbol Name.
#' @param barsType. a character. Bars Type. One from c("Ask", "Bid").
#' @param periodicity. a character. Periodicity. From c("S1", "S10", "M1", "M5", "M15", "M30", "H1", "H4", "D1", "W1","MN1")
#' @param startTimeMs. Long numeric. Timestamp from 1970-01-01 in ms.
#' @param count. Integer. Count of returned Bars from startTimeMs. Max is 1000. Can be negative.
#' @return data.table with Bar Info
RTTWebClient$methods(
GetBarFromWeb = function(symbol, barsType, periodicity, startTimeMs, count){
address <- .self$web_api_address
if(!grepl("^https://", address))
address <- paste0("https://", address)
portPattern <- paste0(":", .self$web_api_port, "$")
if(!grepl(portPattern, address))
address <- paste0(address, ":", .self$web_api_port)
if(length(.self$web_api_id) != 0 && length(.self$web_api_key) != 0 && length(.self$web_api_secret) != 0){
url_rel <- paste("/api/v2/quotehistory",symbol, periodicity, "bars", barsType, sep= "/")
url_rel <- paste0(url_rel,"?","timestamp=",round(startTimeMs, 0),"&count=", count)
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE),
add_headers(Authorization = getHMACHeaders(url_abs, .self$web_api_id, .self$web_api_key, .self$web_api_secret)))
}else{
url_rel <- paste("/api/v2/public/quotehistory",symbol, periodicity, "bars", barsType, sep= "/")
url_rel <- paste0(url_rel,"?","timestamp=",round(startTimeMs, 0),"&count=", count)
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE))
}
data <- httr::content(connect, "text", encoding = "UTF-8")
if(connect$status_code != 200) {
stop(paste("status_code is not OK", connect$status_code, as.character(data)))
}
bars <- fromJSON(data)
bars <- as.data.table(bars$Bars)
return(bars)
}
)
#'Get Ticks History
#' @name GetTicksFromWeb
#' @param symbol. A character. Symbol Name.
#' @param startTimeMs. Long numeric. Timestamp from 1970-01-01 in ms.
#' @param count. Integer. Count of returned Bars from startTimeMs. Max is 1000. Can be negative.
#' @return data.table with Ticks Info.
RTTWebClient$methods(
GetTicksFromWeb = function(symbol, startTimeMs, count){
address <- .self$web_api_address
if(!grepl("^https://", address))
address <- paste0("https://", address)
portPattern <- paste0(":", .self$web_api_port, "$")
if(!grepl(portPattern, address))
address <- paste0(address, ":", .self$.self$web_api_port)
if(length(.self$web_api_id) != 0 && length(.self$web_api_key) != 0 && length(.self$web_api_secret) != 0){
url_rel <- paste("/api/v2/quotehistory",symbol, "ticks", sep= "/")
url_rel <- paste0(url_rel,"?","timestamp=",round(startTimeMs, 0),"&count=", count)
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE),
add_headers(Authorization = getHMACHeaders(url_abs, .self$web_api_id, .self$web_api_key, .self$web_api_secret)))
}else{
url_rel <- paste("/api/v2/public/quotehistory",symbol, "ticks", sep= "/")
url_rel <- paste0(url_rel,"?","timestamp=",round(startTimeMs, 0),"&count=", count)
url_abs <- paste0(address, url_rel)
connect <- httr::GET(url_abs, config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE))
}
data <- httr::content(connect, "text", encoding = "UTF-8")
if(connect$status_code != 200) {
stop(paste("status_code is not OK", connect$status_code, as.character(data)))
}
ticks <- fromJSON(data)
ticks <- ticks$Ticks
ticks <- data.table("Timestamp" = ticks$Timestamp, "BidPrice" = ticks$BestBid$Price,
"BidVolume" = ticks$BestBid$Volume, "BidType" = ticks$BestBid$Type,  "AskPrice" = ticks$BestAsk$Price,
"AskVolume" = ticks$BestAsk$Volume, "AskType" = ticks$BestAsk$Type)
return(ticks)
}
)
#' Init Public Web Client Obj
#'@name InitPublicWebClient
#'@param server a character. Web Address.
#'@param port an integer. Port Number. Default is 8443
InitPublicWebClient <- function(server = "ttlivewebapi.fxopen.com", port=8443L) {
options(scipen = 999)
return(RTTWebClient(web_api_address=server,
web_api_port = port))
}
#' Init Private Web Client Obj
#'@name InitPrivateWebClient
#'@param server a character. Web Address.
#'@param port an integer. Port Number. Default is 8443
#'@param we
InitPrivateWebClient <- function(server = "ttlivewebapi.fxopen.com", port=8443L, id = "", key = "", secret = "") {
options(scipen = 999)
return(RTTWebClient(web_api_address=server,
web_api_port = port,
web_api_id = id,
web_api_key=key,
web_api_secret=secret))
}
#' Init Web connect to TT
#' @name ttInitialize
#' @param
# ttInitialize <- setRefClass("ttInitialize",
#                             fields = list(server = "character", port = "numeric", id = "character", key = "character", secret = "character"),
#                             methods = list(
#                               initialize = function(webClient) {
#                                 if(isPublic)
#                                 .self$webClient = InitPublicWebClient()
#                               }
#                             )
#                             )
WebClient <- setRefClass("WebClient",
fields = list(client = "RTTWebClient"),
methods = list(
initialize = function(newWebClient){
.self$client <- newWebClient
}
))
WebClient$methods(
GetDividends = function() {
return(.self$client$GetDividendsFromWeb())
}
)
WebClient$methods(
GetSymbolsInfo = function() {
return(.self$client$GetSymbolsInfoFromWeb())
}
)
WebClient$methods(
GetCurrentQuotes = function() {
return(.self$client$GetCurrentQuotesFromWeb())
}
)
WebClient$methods(
GetBarsHistory = function(symbol, barsType = "Bid", periodicity = "M1", startTime, endTime = as.POSIXct(Sys.Date(), tz = "GMT"), count = 0) {
if(barsType == "Bid" || barasType == "Ask"){
return(GetBars(.self$client$GetBarFromWeb, symbol, barsType, periodicity, startTime, endTime, count))
}
stop("Wrong Bar Type")
}
)
WebClient$methods(
GetTickHistory = function(symbol, startTime, endTime = as.POSIXct(Sys.Date(), tz = "GMT"), count = 0) {
return(GetTicks(.self$client$GetTicksFromWeb, symbol, startTime, endTime, count))
}
)
# WebClient <- function(server = "ttlivewebapi.fxopen.com", port=8443L, id = NULL, key = NULL, secret = NULL){
#   if(length(id) != 0 && length(key) != 0 && length(secret) != 0)
#     return(ttInitialize$new(InitPrivateWebClient(server, port, id, key, secret)))
#   return(ttInitialize$new(InitPublicWebClient(server, port)))
# }
#' Init WebClient
#'@param server a character. Web Address.
#'@param port an integer. Port Number. Default is 8443
#'@param id a character. HMAC client id.
#'@param key a character. HMAC client key.
#'@param secret a character. HMAC secret key.
#'@return WebClient ref class.
#'@export
InitWebClient <- function(server = "ttlivewebapi.fxopen.com", port=8443L, id = NULL, key = NULL, secret = NULL){
if(length(id) != 0 && length(key) != 0 && length(secret) != 0)
return(ttInitialize$new(InitPrivateWebClient(server, port, id, key, secret)))
return(ttInitialize$new(InitPublicWebClient(server, port)))
}
r <- InitWebClient()
#' Init WebClient
#'@param server a character. Web Address.
#'@param port an integer. Port Number. Default is 8443
#'@param id a character. HMAC client id.
#'@param key a character. HMAC client key.
#'@param secret a character. HMAC secret key.
#'@return WebClient ref class.
#'@export
InitWebClient <- function(server = "ttlivewebapi.fxopen.com", port=8443L, id = NULL, key = NULL, secret = NULL){
if(length(id) != 0 && length(key) != 0 && length(secret) != 0)
return(WebClient$new(InitPrivateWebClient(server, port, id, key, secret)))
return(WebClient$new(InitPublicWebClient(server, port)))
}
r <- InitWebClient()
r$GetDividends()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
install.packages("C:/Users/yury.maisiayonak/Desktop/RTTWebClient_0.1.0.tar.gz", repos = NULL, type = "source")
library(RTTWebClient)
help(package = "RTTWebClient")
help(package = "RTTWebClient")
library(RTTWebClient)
t1 <- InitWebClient()
t1$GetSymbolsInfo()
r <- t1$GetSymbolsInfo()
library(lubridate)
t1$GetTickHistory("EURUSD", now("UTC") - hours(1), now("UTC"))
library(rhub)
rhub::check_for_cran()
help("Documentation", package = "methods")
methods ? GetDividendsFromWeb
promptMethods ("GetDividendsFromWeb")
promptMethods ("GetBars")
rhub::check_for_cran()
rhub::check_for_cran()
detach("package:RTTWebClient", unload = TRUE)
install.packages("C:/Users/yury.maisiayonak/Desktop/RTTWebClient_0.1.0.tar.gz", repos = NULL, type = "source")
install.packages("C:/Users/yury.maisiayonak/Desktop/RTTWebClient_0.1.0.tar.gz", repos = NULL, type = "source")
library(RTTWebClient)
t1 <- InitPrivateWebClient()
t1$GetCurrentQuotesFromWeb()
t1 <- InitPublicWebClient()
t1$GetCurrentQuotesFromWeb()
library(RTTWebClient)
ttWebClient <- InitPublicWebClient(server = "tt.tt-ag.st.soft-fx.eu")
help(package = "RTTWebClient")
ttWebClient$GetTickHistory("EURUSD",  round(as.double(Sys.time()) * 1000), count = -10)
ttWebClient <- InitPublicWebClient(server = "tt.tt-ag.st.soft-fx.eu")
print(ttWebClient$GetTicksFromWeb("EURUSD",  round(as.double(Sys.time()) * 1000), count = -10))
t1 <- Sys.time()
t1
t1 - 10
library(RTTWebClient)
library(lubridate)
ttWebApiHost <- InitRTTWebApiHost(server = "tt.tt-ag.st.soft-fx.eu")
tt1 <- InitWebClient()
devtools::release()
devtools::spell_check()
devtools::release()
