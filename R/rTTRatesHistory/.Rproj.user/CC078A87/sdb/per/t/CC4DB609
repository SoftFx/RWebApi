{
    "collab_server" : "",
    "contents" : "\nGetBars <- function(server, symbol, barsType = \"Bid\", periodicity = \"M1\", startTime, endTime) {\n  querryInit <- paste(\"https://\", server,\"/api/v1/public/quotehistory\",symbol, periodicity, \"bars\", barsType, sep= \"/\")\n  startTime <- as.double(startTime)*1000\n  tempStartTime <- startTime\n  history <- data.table()\n  repeat{\n    querry <- paste0(querryInit,\"?\",\"timestamp=\",tempStartTime,\"&count=\", 1000)\n    connect <- GET(querry, config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE, sslversion = 6))\n    if(connect$status_code != 200) {\n      stop(paste(\"status_code is not OK\", connect$status_code))\n    }\n    data <- content(connect, \"text\", encoding = \"UTF-8\")\n    bars <- fromJSON(data)\n    bars <- as.data.table(bars$Bars)\n    bars <- bars[, Timestamp:= Timestamp/1000]\n    bars <- bars[, Timestamp:=as.POSIXct(Timestamp, origin = \"1970-01-01\", tz = \"GMT\")]\n    excludeIndex <-ifelse(is.null(history[.N]$Timestamp), numeric(0), bars[Timestamp==history[.N]$Timestamp,which=T])\n    if(!is.na(excludeIndex))\n      bars <-bars[-excludeIndex]\n    if(nrow(bars) == 0) {\n      break;\n    }else{\n      if(bars[.N]$Timestamp >= endTime){\n        history = rbind(history, bars[Timestamp <= endTime])\n        break;\n      }\n    }\n    history <- rbind(history, bars)\n    tempStartTime <- as.double(history[.N]$Timestamp)*1000\n  }\n  setkey(history, Timestamp)\n  return(history)\n}\n\nGetBidAskBar <- function(server, symbol, periodicity = \"M1\", startTime, endTime) {\n  bidBars <- GetBars(server, symbol, barsType = \"Bid\", periodicity, startTime, endTime)\n  askBars <- GetBars(server, symbol, barsType = \"Ask\", periodicity, startTime, endTime)\n  bidAskBars <- merge(bidBars, askBars)\n  colnames(bidAskBars) <- c(\"Timestamp\", \"BidVolume\", \"BidClose\", \"BidLow\", \"BidHigh\", \"BidOpen\",\n                            \"AskVolume\", \"AskClose\", \"AskLow\", \"AskHigh\", \"AskOpen\")\n  return(bidAskBars)\n}\n\n#' Set the server from which the info will be read\n#'@param serverName a character. Server\n#'@param port a numeric. Port number\n#'@examples\n#'connection <- ttInitialize(serverName = \"cryptottlivewebapi.xbtce.net\", port = \"8443\")\n#'\n#'symbols <- connection$GetSymbolsInfo()\n#'\n#'bars <- connection$GetBarsHistrory(\"BTCUSD\", barsType = \"Bid\", periodicity = \"M1\", as.POSIXct(\"2018-10-12 00:00:00\", tz = \"GMT\"), as.POSIXct(\"2018-10-12 05:00:00\", tz = \"GMT\"))\n#'\n#'ticks <- connection$GetTickHistory(\"BTCUSD\", as.POSIXct(\"2018-10-12 00:00:00\", tz = \"GMT\"), as.POSIXct(\"2018-10-12 05:00:00\", tz = \"GMT\"))\n#'\n#'currentQuotes <- connection$GetCurrentQuotes()\n#'@export\nttInitialize <- function(serverName = \"cryptottlivewebapi.xbtce.net\", port = \"8443\"){\n  options(scipen = 999, digits.secs = 6)\n  require(data.table)\n  require(jsonlite)\n  require(httr)\n  server <- paste(serverName, port, sep = \":\")\n  list(\n    GetSymbolsInfo = function(){\n      querry = paste0(\"https://\", server, \"/api/v1/public/symbol\")\n      connect = GET(querry, config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE, sslversion = 6))\n      if(connect$status_code != 200) {\n        stop(paste(\"status_code is not OK\", connect$status_code))\n      }\n      data = content(connect, \"text\", encoding = \"UTF-8\")\n      data = fromJSON(data)\n      symbols <- as.data.table(data)\n      setkey(symbols, \"Symbol\")\n      return(symbols)\n    },\n    GetCurrentQuotes = function() {\n      querry <-  paste0(\"https://\", server,\"/api/v1/public/tick\")\n      connect <- GET(querry, config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE, sslversion = 6))\n      if(connect$status_code != 200) {\n        stop(paste(\"status_code is not OK\", connect$status_code))\n      }\n      data <- content(connect, \"text\", encoding = \"UTF-8\")\n      ticks <- fromJSON(data)\n      ticks <- data.table(\"TimeStamp\" = ticks$Timestamp, \"Symbol\" = ticks$Symbol, \"BidPrice\" = ticks$BestBid$Price,\n                          \"BidVolume\" = ticks$BestBid$Volume, \"BidType\" = ticks$BestBid$Type,  \"AskPrice\" = ticks$BestAsk$Price,\n                          \"AskVolume\" = ticks$BestAsk$Volume, \"AskType\" = ticks$BestAsk$Type)\n\n      setkey(ticks, Symbol)\n      return(ticks)\n    },\n    GetBarsHistrory = function(symbol, barsType = \"Bid\", periodicity = \"M1\", startTime, endTime){\n      if(barsType == \"BidAsk\"){\n        return(GetBidAskBar(server, symbol, periodicity, startTime, endTime))\n      }\n      if(barsType == \"Bid\" | barsType == \"Ask\"){\n        return(GetBars(server, symbol, barsType, periodicity, startTime, endTime))\n      }\n      stop(\"Wrong barsType\")\n    },\n    GetTickHistory = function(symbol, startTime, endTime) {\n      querryInit <- paste(\"https://\", server,\"/api/v1/public/quotehistory\",symbol, \"ticks\", sep= \"/\")\n      startTime <- as.double(startTime)*1000\n      tempStartTime <- startTime\n      history <- data.table()\n      httr::config(ssl_verifypeer = 0L, ssl_verifyhost = 0L, verbose = FALSE, sslversion = 6)\n      repeat{\n        querry <- paste0(querryInit,\"?\",\"timestamp=\",tempStartTime,\"&count=\", 1000)\n        connect <- GET(querry)\n        if(connect$status_code != 200) {\n          stop(paste(\"status_code is not OK\", connect$status_code))\n        }\n        data <- content(connect, \"text\", encoding = \"UTF-8\")\n        ticks <- fromJSON(data)\n        ticks <- ticks$Ticks\n        ticks <- data.table(\"Timestamp\" = ticks$Timestamp, \"BidPrice\" = ticks$BestBid$Price,\n                            \"BidVolume\" = ticks$BestBid$Volume, \"BidType\" = ticks$BestBid$Type,  \"AskPrice\" = ticks$BestAsk$Price,\n                            \"AskVolume\" = ticks$BestAsk$Volume, \"AskType\" = ticks$BestAsk$Type)\n        ticks <- ticks[, Timestamp:= Timestamp/1000]\n        ticks <- ticks[,Timestamp:=as.POSIXct(Timestamp, origin = \"1970-01-01\", tz = \"GMT\")]\n        excludeIndex <-ifelse(is.null(history[.N]$Timestamp), numeric(0), ticks[Timestamp==history[.N]$Timestamp,which=T])\n        if(!is.na(excludeIndex))\n          ticks <-ticks[-excludeIndex]\n        if(nrow(ticks) == 0) {\n          break;\n        }else{\n          if(ticks[.N]$Timestamp >= endTime){\n            history = rbind(history, ticks[Timestamp <= endTime])\n            break;\n          }\n        }\n        history <- rbind(history, ticks)\n        tempStartTime <- as.double(history[.N]$Timestamp)*1000\n        # tempStartTime1 = as.POSIXct(tempStartTime/1000, origin = \"1970-01-01\", tz = \"GMT\")\n      }\n      setkey(history, Timestamp)\n      return(history)\n    }\n  )\n}\n",
    "created" : 1544630494637.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "589180813",
    "id" : "CC4DB609",
    "lastKnownWriteTime" : 1544719070,
    "last_content_update" : 1544719741285,
    "path" : "C:/Users/yury.maisiayonak/Work/RPackages/rTTRatesHistory/R/rTTRatesHistory.R",
    "project_path" : "R/rTTRatesHistory.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}